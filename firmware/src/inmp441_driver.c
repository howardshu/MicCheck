#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"

#define I2S_READ_BUFFER_SIZE 1024

static const char *TAG = "i2s_inmp441";

static void i2s_read(void *pvParameters) {
    i2s_chan_handle_t rx_handle;
    // get default channel configuration by helper macro (defined in i2s_common.h)
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    // Allocate a new RX channel and get the handle of this channel
    if(i2s_new_channel(&chan_cfg, NULL, &rx_handle) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to create I2S channel\n");
        abort();
    } else {
        ESP_LOGI(TAG, "Successfully created I2S channel");
    }

    // setting the config with slot config and clock config generated by the macros (defined in i2s_std.h)
    // inmp441 wired to output in left channel, uses MSB slot mode
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(48000),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_MONO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = GPIO_NUM_4,
            .ws = GPIO_NUM_5,
            .dout = I2S_GPIO_UNUSED,
            .din = GPIO_NUM_19,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };
    // initialize channel
    i2s_channel_init_std_mode(rx_handle, &std_cfg);

    // start the RX channel
    i2s_channel_enable(rx_handle);
    while (1) {
        uint8_t buffer[I2S_READ_BUFFER_SIZE];
        size_t bytes_read;
        esp_err_t ret = i2s_channel_read(rx_handle, buffer, sizeof(buffer), &bytes_read, 1000);
        if (ret == ESP_OK && bytes_read > 0) {
            // printing samples as 32-bit signed integers
            int32_t *samples = (int32_t *)buffer;
            for (int i = 0; i < bytes_read / sizeof(int32_t); i++) {
                // inmp441 typically outputs 24-bit data with MSB as the 2nd bit sent and LSB as 25th bit sent within 32-bit word
                // esp32 is little endian
                int32_t raw_sample = samples[i];
                int32_t audio_sample = raw_sample << 1;
                audio_sample >>= 8;
                ESP_LOGI(TAG, "Sample[%d]: %ld", i, audio_sample);
            }
        } else {
            ESP_LOGW(TAG, "Read timeout or error: %s", esp_err_to_name(ret));
        }
    }

    // stop the channel
    i2s_channel_disable(rx_handle);
    // delete handle to release channel resources
    i2s_del_channel(rx_handle);
}

void inmp441_driver_run(void)
{
    // create task to read from I2S
    // arguments: function, task name, stack size, task parameters, task priority, task handle
    xTaskCreate(i2s_read, "i2s_read", 8192, NULL, 5, NULL);
}